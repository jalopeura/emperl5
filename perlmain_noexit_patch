--- perlmain.c.orig	2023-08-07 09:00:53.149530483 -0700
+++ perlmain.c	2023-08-07 08:59:46.000000000 -0700
@@ -54,14 +54,13 @@
 static void xs_init (pTHX);
 static PerlInterpreter *my_perl;
 
+int emperl_end_perl();
+
 #ifdef NO_ENV_ARRAY_IN_MAIN
-extern char **environ;
-int
-main(int argc, char **argv)
-#else
+#error "NO_ENV_ARRAY_IN_MAIN not supported in this configuration"
+#endif
 int
 main(int argc, char **argv, char **env)
-#endif
 {
     int exitstatus, i;
 #ifndef NO_ENV_ARRAY_IN_MAIN
@@ -72,25 +71,10 @@
     /* noop unless Configure is given -Accflags=-DPERL_GPROF_CONTROL */
     PERL_GPROF_MONCONTROL(0);
 
-#ifdef NO_ENV_ARRAY_IN_MAIN
-    PERL_SYS_INIT3(&argc,&argv,&environ);
-#else
     PERL_SYS_INIT3(&argc,&argv,&env);
-#endif
 
 #if defined(USE_ITHREADS)
-    /* XXX Ideally, this should really be happening in perl_alloc() or
-     * perl_construct() to keep libperl.a transparently fork()-safe.
-     * It is currently done here only because Apache/mod_perl have
-     * problems due to lack of a call to cancel pthread_atfork()
-     * handlers when shared objects that contain the handlers may
-     * be dlclose()d.  This forces applications that embed perl to
-     * call PTHREAD_ATFORK() explicitly, but if and only if it hasn't
-     * been called at least once before in the current process.
-     * --GSAR 2001-07-20 */
-    PTHREAD_ATFORK(Perl_atfork_lock,
-                   Perl_atfork_unlock,
-                   Perl_atfork_unlock);
+#error "USE_ITHREADS not supported in this configuration"
 #endif
 
     PERL_SYS_FPU_INIT;
@@ -103,29 +87,33 @@
 	PL_perl_destruct_level = 0;
     }
     PL_exit_flags |= PERL_EXIT_DESTRUCT_END;
-    if (!perl_parse(my_perl, xs_init, argc, argv, (char **)NULL)) {
-
-        /* perl_parse() may end up starting its own run loops, which
-         * might end up "leaking" PL_restartop from the parse phase into
-         * the run phase which then ends up confusing run_body(). This
-         * leakage shouldn't happen and if it does its a bug.
-         *
-         * Note we do not do this assert in perl_run() or perl_parse()
-         * as there are modules out there which explicitly set
-         * PL_restartop before calling perl_run() directly from XS code
-         * (Coro), and it is conceivable PL_restartop could be set prior
-         * to calling perl_parse() by XS code as well.
-         *
-         * What we want to check is that the top level perl_parse(),
-         * perl_run() pairing does not allow a leaking PL_restartop, as
-         * that indicates a bug in perl. By putting the assert here we
-         * can validate that Perl itself is operating correctly without
-         * risking breakage to XS code under DEBUGGING. - Yves
-         */
-        assert(!PL_restartop);
-
-        perl_run(my_perl);
+    if (perl_parse(my_perl, xs_init, argc, argv, (char **)NULL))
+        return emperl_end_perl();
+    if (perl_run(my_perl))
+        return emperl_end_perl();
+
+    /* Code copied from perl_destruct in perl.c */
+#ifdef USE_PERLIO
+    {
+        PerlIO *stdo = PerlIO_stdout();
+        if (*stdo && PerlIO_flush(stdo)) {
+            PerlIO_restore_errno(stdo);
+            if (errno)
+                PerlIO_printf(PerlIO_stderr(), "Unable to flush stdout: %s\n",
+                    Strerror(errno));
+            if (!STATUS_UNIX)
+                STATUS_ALL_FAILURE;
+        }
     }
+#endif
+    my_fflush_all();
+    return STATUS_EXIT;
+}
+
+int
+emperl_end_perl()
+{
+    int exitstatus, i;
 
 #ifndef PERL_MICRO
     /* Unregister our signal handler before destroying my_perl */
@@ -142,7 +130,13 @@
 
     PERL_SYS_TERM();
 
-    exit(exitstatus);
+    /* When NO_EXIT_RUNTIME is set, Emscripten throws an ExitStatus exception when
+     * exit() is called, so we only call it when there is a nonzero exit status.
+     * As far as I can tell, Perl doesn't require exit() to be called (for example,
+     * END blocks are apparently handled above, and not via atexit). */
+    if (exitstatus)
+        exit(exitstatus);
+    return exitstatus;
 }
 
 /* Register any extra external extensions */
